Заголовок Команды для организации циклов

(слайд с loop метками)

В форме 1 из содержимого CX вычитается единица, если окажется, что
CX != 0, то управление передаётся на указанную метку (CX содержит
колличество иттераций)

Во второй форме из CX вычитается 1, если CX !=0 и ZF == 1, то
управление передаётся на указанную метку. А это значит, что цикл 
завершается, происходит выход из цикла (передаётся управление 
следующее за loop), или CX = 0, или ZF = 0, или это произойдёт
одновременно.

В 3 варианте уменьшается содержимое CX если CX != 0 и одновременно
ZF = 0, то управление передаётся на указанную метку, если условие
нарушено, то происходит выход из цикла.

Примеры циклов (слайд с loop метками)

Если CX используется для других целей, тогда можно поступить
следующим образом 

mov SI, 0 (дальше с того же слайда)

Дана матрица целых байтовых величин размером 4 на 5, нужно
аодсчитать колличество 0 в каждой строке матрицы, заменить
0 на константы, например 0FF, будем решать задачу с помощью директив
стандартной сегментации, выделив под стек 256 байтов, а 
кодовый сегмент оформим как 2 последовательные процедуры. 
Внешняя реализует связь с операционной системой и
обращается к внутренней процедуре, решающей поставленную
задачу

(пример с слайда) + дописать комментарии

title prim.asm

page , 132

Sseg  segment para stack 'stack'

      db 256 dup (?)

Sseg  ends

Dseg  segment para public 'data'

Dan   db 0,2,5,0,91

      db 4,0,0,15,47

      db 24,15,0,9,55

      db 1,7,12,0,4

Dseg  ends

Cseg  segment para public 'code'

      Assume cs: cseg, ds:dseg, ss:sseg 

start proc far 

      PUSH DS 

      PUSH AX

      mov BX,Dseg

      mov DS,BX

      call main

      ret

start endp

main  proc near

      mov BX, offset Dan

      mov CX, 4

nz1:  PUSH CX

      mov Dl, 0

      mov SI, 0

      mov CX, 5  

nz2:  PUSH CX

      cmp byte ptr[BX+SI], 0

      jne mz

      mov byte ptr[BX+SI], 0FFh

      inc DL 

mz:   inc SI

      POP CX

kz2:  loop nz2

      add DL, 0

      mov AH, 6

      int 21h

      add BX, 5

      pop CX

kz:1  loop nz1

      ret

main  endp

Cseg  ends

end start                  

Заголовок организация циклов в ассемблере

Массивы описываются, определяются с помощью директив определения
данных и памяти, возможно с помощью кострукции повторения dup

Например:

x DW 30 dup (?) - выделила в памяти место под одномерный массив x
(массив слов), состоящий из 30 элементов, но в этом описании
неясно как мы будем нумеровать элементы массивы, мы можем пронумеровать
их от 0 до 29, может от 1 до 30, а может от k до 29+k, в зависимости
от постановки задачи, если это не обговорено, то удобнее нумеровать в
ассемблере с 0, потому что адрес любого элемента массива булет записываться
наиболее происходит

Можем записать 

адрес (x[i]) = x + (type x) * i

Для двумерного массива - A[0..n-1, 0..m-1]

адрес (i,j) можно вычислить так

адрес (A[i,j]) = A + m * (type A) * i + (type A) * j

Например для нашего одномерного массива это было

x + 2*i = x + type(x) * i

Адрес состоит из двух частей. Из постоянной части x и переменной
2 * i, поэтому логично использовать для адресации элементов одномерного
масиива прямую индексацию со смещением, т.е. 
х - смещение, а 2*i - в регистре SI или DI

место под двумерный массив можно выделить следующим образом:

A     DD n DUP (m Dup (?)) - двумерный массив слов размером n на m

Если мы будем нумеровать от 0 элементы строк и столбцов, то 
адрес (A[i,j]) = A + m * 4 * i + 4 * j

А - постоянная, переменные m * 4 * i и 4 * j, то есть адресация
по базе с индексированием.

Фрагмент программы,в которой в регистр AL записывается колличество
сток матрицы байтов размерность 10*20, тип элементов - byte,
имя массива - x. Посчитаем колличество строк матрицы, в которых
1-ый элемнт повторяется не менее 1 раза.

(Программа на слайде)

Заголовок Комады побитовой обработки данных

К ним отностятся:

1) логические команды,

2) команды сдвига

3) Установки

4) сброса

5) инверсии битов

Логические (с слайда)

Второй операнд в этих командах называют маской, а основным назначением
команды and - установка в 0 с помощью маски соответствующих разрядов
первого операнда, потому что нулевые разряды маски обнуляют соответствующие
разряды первго операнда, а единичные оставляют без изменения.

Маску можно задаваьт как константу в команде, можно хранить в регистре
или в памяти. Соответсвенно можно использовать любой способ адресации

Пример (соответствующий слайд)

Команда or OP1, OP2 - ложь только если оба разряда ложь, эта команда 
используется для установки в 1 некоторых разрядов первого операнда
в соответствии с маской - OP2

Пример (соответствующий слайд)

В команде могут использоваться различные способы адресации:

пример (соответствующий слайд)

Команда xor OP1, OP2, если операнды одинаковые, то результат 0, 
если различные, то результат 1

Пример (соответствующий слайд)

Команда not выполняет инверсию операнда. Значение при это не 
изменяется.

Команды xor обнуляет регистр AX быстрее, чем mov и sub

(слайд после этой строки)

Определить колличество задолжников в группе из 20 студентов,
информация содержится в массиве байтов X DB 20 DUP (?), причём
(соответствующие слайды (2))

Команды сдвига

Арифметические логические команды сдвига : первая буква s, вторая
определяет тип сдвига логический или арифметический, 3 определяет
влево или вправо, причём первый оператор может быть регистром или
памятью, а второй это константа или регистр CL, в котором используется
5 младших разрядов.

Пример (соответствующий слайд) + следующий слайд про сдвиги больше
чем на 1

Циклические сдвиги (соответствующий слайд)

+ ещё следующий слайд

Циклические сдвиги с переносом содержимого флажка CF (соот)

для всех команд сдвига флажки ZF, SF, PF, устанавливаются в соответствии
с результатом, AF тоже неопределён. OF - не определён при сдвигах
на несколько разрядов, а при сдвигах  на 1 разряд в зависимости от 
команды (слайд)

Для самостоятельного изучения (соответствующий слайд)