\begin{center}
      \Large{\textbf{Команды для организации циклов}}
\end{center}

\begin{center}
      \includegraphics[width = 90mm]{6_1.png}
\end{center}

1) В форме 1 из содержимого CX вычитается единица, если окажется, что
CX != 0, то управление передаётся на указанную метку (CX содержит
колличество иттераций) \smallskip

2) Во второй форме из CX вычитается 1, если CX !=0 и ZF == 1, то
управление передаётся на указанную метку. 

Цикл завершается, если (передаётся управление 
на команду, следующую за loop), CX == 0, или ZF == 0, или это
произойдёт одновременно. \smallskip

3) В 3 варианте уменьшается содержимое CX если CX != 0 и одновременно
ZF = 0, то управление передаётся на указанную метку, если условие
нарушено, то происходит выход из цикла. 

\begin{center}
      \includegraphics[width = 100mm]{6_2.png}
\end{center}

\begin{center}
      \Large{\textbf{Пример использования команд усл. перехода, сравнения
      и циклов}}
\end{center}

\textbf{Дана матрица целых байтовых величин размером 4 на 5}, нужно
подсчитать колличество 0 в каждой строке матрицы, заменить
0 на константы, например 0FFh, будем решать задачу с помощью директив
стандартной сегментации, выделив под стек 256 байтов, а 
кодовый сегмент оформим как 2 последовательные процедуры. 
Внешняя реализует связь с операционной системой и
обращается к внутренней процедуре, решающей поставленную
задачу

\begin{center}
      \includegraphics[width = 100mm]{6_3.png}
      \includegraphics[width = 100mm]{6_4.png}
      \includegraphics[width = 105mm]{6_5.png}
\end{center}            

\begin{center}
      \includegraphics[width = 110mm]{6_6.png}
\end{center}

\begin{center}
      \Large{\textbf{Массивы в Ассемблере}}
\end{center}

\textbf{Массивы описываются}, определяются с помощью директив определения
данных и памяти, возможно с помощью кострукции повторения dup \smallskip

Например:

\textbf{x DW 30 dup (?)}~--- выделила в памяти место под одномерный
массив x (массив слов), состоящий из 30 элементов, но в этом описании
неясно как мы будем нумеровать элементы массивы, мы можем пронумеровать
их от 0 до 29, может от 1 до 30, а может от k до 29+k, в зависимости
от постановки задачи, если это не обговорено, то удобнее нумеровать в
ассемблере с 0, потому что адрес любого элемента массива будет
записываться наиболее просто: 

\begin{center}
      \textbf{адрес (x[i]) = x + (type x) * i}
\end{center}

\textbf{Для двумерного массива}~--- A[0..n-1, 0..m-1]
адрес (i,j) можно вычислить так \smallskip

\begin{center}
      \textbf{адрес (A[i,j]) = A + m * (type A) * i + (type A) * j}
\end{center}

Например для нашего одномерного массива это было

\begin{center}
      \textbf{x + 2*i = x + type(x) * i}
\end{center}

\textbf{Адрес состоит из двух частей.} Из постоянной части x и переменной
2 * i, поэтому логично использовать для адресации элементов одномерного
масиива прямую индексацию со смещением, т.е. 
х~--- смещение, а 2*i~--- в регистре SI или DI

место под двумерный массив можно выделить следующим образом:

\begin{center}
      \includegraphics[width = 90mm]{6_7.png}
\end{center}

Если мы будем нумеровать от 0 элементы строк и столбцов, то 
адрес \textbf{(A[i,j]) = A + m * 4 * i + 4 * j}

А~--- постоянная, переменные m * 4 * i и 4 * j, то есть адресация
по базе с индексированием. \smallskip

\textbf{Фрагмент программы}, в которой в регистр AL записывается колличество
строк матрицы байтов размерность 10*20, тип элементов~--- byte,
имя массива~--- x. Посчитаем колличество строк матрицы, в которых
1"=ый элемнт повторяется не менее 1 раза.

\begin{center}
      \includegraphics[width = 110mm]{6_8.png}
\end{center}

\begin{center}
      \Large{\textbf{Комады побитовой обработки данных}}
\end{center}

\textbf{К ним отностятся:} \smallskip

1) логические команды, 

2) команды сдвига,

3) установки,

4) сброса,

5) инверсии битов \smallskip

\begin{center}
      \includegraphics[width = 110mm]{6_9.png}
\end{center}

Второй операнд в этих командах называют маской, а основным назначением
команды and~--- установка в 0 с помощью маски соответствующих разрядов
первого операнда, потому что нулевые разряды маски обнуляют соответствующие
разряды первго операнда, а единичные оставляют без изменения.

Маску можно задавать как константу в команде, можно хранить в регистре
или в памяти. Соответсвенно можно использовать любой способ адресации

\begin{center}
      \includegraphics[width = 110mm]{6_10.png}
\end{center}

Команда or OP1, OP2~--- ложь только если оба разряда ложь, эта команда 
используется для установки в 1 некоторых разрядов первого операнда
в соответствии с маской - OP2

\begin{center}
      \includegraphics[width = 100mm]{6_11.png}
\end{center}

В команде могут использоваться различные способы адресации:

\begin{center}
      \includegraphics[width = 110mm]{6_12.png}
\end{center}

Команда xor OP1, OP2, если операнды одинаковые, то результат 0, 
если различные, то результат 1

\begin{center}
      \includegraphics[width = 100mm]{6_13.png}
\end{center}

Команда not OP выполняет инверсию операнда. Значение при это не 
изменяется.

\begin{center}
      \includegraphics[width = 90mm]{6_14.png}
\end{center}

Команда xor обнуляет регистр AX быстрее, чем mov и sub

\begin{center}
      \includegraphics[width = 110mm]{6_15.png}
\end{center}

\textbf{Определить колличество задолжников в группе из 20 студентов},
информация содержится в массиве байтов X DB 20 DUP (?), причём
причём в младших 4 битах каждого байта содержатся оценки, т.е.
1~--- сдал экзамен, 0~--- хвост. В DL сохраним колличество
задолжников.

\begin{center}
      \includegraphics[width = 110mm]{6_16.png}
\end{center}

\begin{center}
      \Large{\textbf{Команды сдвига}}
\end{center}

Арифметические логические команды сдвига : первая буква s, вторая
определяет тип сдвига логический или арифметический, 3 определяет
влево или вправо, причём первый оператор может быть регистром или
памятью, а второй это константа или регистр CL, в котором используется
5 младших разрядов.

\begin{center}
      \includegraphics[width = 110mm]{6_17.png}
      \includegraphics[width = 110mm]{6_18.png}
\end{center}

\begin{center}
      \includegraphics[width = 100mm]{6_19.png}
      \includegraphics[width = 110mm]{6_20.png}
\end{center}

для всех команд сдвига флажки ZF, SF, PF, устанавливаются в соответствии
с результатом, AF тоже неопределён. OF - не определён при сдвигах
на несколько разрядов, а при сдвигах  на 1 разряд в зависимости от 
команды:

\begin{center}
      \includegraphics[width = 100mm]{6_21.png}
      \includegraphics[width = 110mm]{6_22.png}
\end{center}