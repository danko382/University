\begin{center}
    \Large{\textbf{Директива Определения}}
\end{center}

\textbf{Общий вид директивы определения следующий:}

\begin{center}
    \includegraphics[width = 80mm]{4_1.png}
\end{center}

В поле операндов может быть '?', одна или несколько констант,
разделённых запятой. Имя, если оно есть, определяет адрес первого байта
выделяемой области. Директивой выделяется указанное количество
байтов ОП и указанные операнды пересылаются в эти поля памяти. Если 
операнд~--- это '?', то в соответсвующее поле ничего не заносится.

\begin{center}
    \includegraphics[width = 100mm]{4_2.png}
\end{center}

\textbf{1) Если операндом является} символическое имя IM1, которое 
соответсвует смещению в сегменте 03AC1h, то после выполнения

\begin{center}
    \textbf{M DD IM1}
\end{center}

будет выделено 4 байта памяти. Адрес~--- M. Значение~--- 03AC1h. \smallskip

\textbf{2) Если необходимо выделить} 100 байтов памяти и заполнить 1,
то это можно сделать с помощью специального повторителя DUP.

\begin{center}
    \textbf{D DB 100 DUP(1)}
\end{center}

\textbf{3) Определение одноменого массива слов}, адрес первого элемента 
массива~--- имя MAS, значение его 1.

\begin{center}
    \textbf{MAS DW 1,7,35,75,84}
\end{center}

\textbf{4) Определение двумерного массива:}

\begin{center}
    \includegraphics[width = 60mm]{4_3.png}
\end{center}

\textbf{5) Const EQU 100}

D DB Const DUP (?); выделить 100 байтов памяти. В директиве определения
байта (слова) максимально допустимая константа~--- 255 (65535).

С помощью директивы определения байта можно определить строковую константу
длиной 255 символов, а с помощью определения слова можно определить строковую
константу, которая может содержать не более двух символов.

\begin{center}
    \Large{\textbf{Команда прерывания Int, команды работы с текстом}}
\end{center}

\textbf{С помощью этой команды} приостанавливается работа процессора,
управление передаётся DOC или BIOS и после выполнения какой"=то системной
обрабатывающей программы, управление передаётся команде, следующей за
командой Int.

Выполняемые действия будут зависеть от операнда, параметра команды Int и 
содержания некоторых регистров.

\begin{center}
    \includegraphics[width = 80mm]{4_4.png}
\end{center}

Стек определяется с мопощью регистров SS и SP (ESP).

Сегментный регистр SS содержит адрес начала сегмента стека.

ОС сама выбирает этот адрес и пересылает его в регистр SS.

Регистр SP указывает на вершину стека и при добавлении элемента стека
содержимое этого регистра уменьшается на длину операнда. Добавить 
элемент в стек можно с помощью команды

\begin{center}
    \textbf{PUSH<операнд>}
\end{center}

где операндом может быть как регистр, так и переменная.

Удалить элемент с вершины стека можно с помощью операции

\begin{center}
    \textbf{POP<операнд>}
\end{center}

\textbf{Для i186 и > PUSHA/POPA} позволяют положить в стек и удалить
содержимое всех регистров общего назначения в последовательности 
AX, BX, CX, DX, SP, BP, SI, DI. \smallskip

\textbf{Для i386 и > PUSHAD/POPAD} позволяют положить в стек,
удалить содержимое всех регистров общего назначения в последовательности
EAX, EBX, ECX, EDX, ESP, EBP, ESI, EDI. \smallskip

\textbf{К любому элементу стека можно обратиться следующим образом}

\begin{center}
    \includegraphics[width = 60mm]{4_5.png}
\end{center}

\textbf{Пример программы использующей директивы пересылки содержимого}
4 байтов памяти и вывод на экран

\begin{center}
    \includegraphics[width = 60mm]{4_6.png}
    \newpage
    \includegraphics[width = 100mm]{4_7.png}
    \includegraphics[width = 100mm]{4_8.png}
\end{center}

\begin{center}
    \Large{\textbf{Директива сегмента}}
\end{center}

Общий вид

\begin{center}
    \textbf{<имя>Segment<ReadOnly><выравнивание><тип><размер><'класс'>}
\end{center}

Любой из операндов может отсутствовать. \smallskip

1) Если есть <ReadOnly>, то будет выведено сообщение об ошибке при попытке
записи в сегмент. \smallskip

2) Операнд <выравнивание> определяет адрес начала сегмента. \smallskip

BYTE~--- адрес начала сегмента может быть любым,

WORD~--- адрес начала сегмента кратен 2,

DWORD~--- адрес начала сегмента кратен 4,

Para~--- адрес начала сегмента кратен 16~---(по умолчанию),

Page~--- адрес начала сегмента кратен 256. \smallskip

3) <тип> определяет тип объединения сегментов. \smallskip

Значение \textbf{stack} указывается в сегменте стека, для остальных
сегментов~--- public. Если такой параметр присутствует, то все сегменты с
одним именем и различными классами объединяются в один последовательно,
в порядке их записи. \smallskip

Значение \textbf{'Common'} говорит, что сегменты с одним именем объединены,
но не последовательно, а с одного и того же адреса так, что общий размер
сегмента будет равен не сумме, а максимуму из них. \smallskip

Значение \textbf{IT <выражение>}~--- указывает на то, что сегмент должен
располагаться по фиксированному абсолютному адресу, определённому
операндом \textbf{<выражение>}, \smallskip

Значение \textbf{'Private'} означает, что этот сегмент ни с каким другим
объединяться не должен. \smallskip

4) <разрядность> use 16~--- сегмент до 64 Кб, \smallskip

use 32~--- сегмент до 4 Гб \smallskip

5) <'класс'>~--- с одинаковым классом сегменты располагаются в исполняемом 
файле последовательно друг за другом.

\begin{center}
    \Large{\textbf{Точечные директивы}}
\end{center}

\textbf{В программе на Ассемблере} могут использоваться упрощённые (точечные)
директивы. \smallskip

\textbf{.MODEL}~--- директива, определяющая модель выделяемой памяти
для программы. \smallskip

Модель памяти определяется параметром: \smallskip

\textbf{tiny}~--- под всю программу выделяется 1 сегмент памяти, \smallskip

\textbf{small}~--- под данные и под программу выделяется по одному 
сегменту, \smallskip

\textbf{medium}~--- под данные выделяется 1 сегмент, под программу 
выделяется несколько сегментов, \smallskip

\textbf{compact}~--- под программу выделяется 1 сегмент, под данные
выделяется несколько сегментов, \smallskip

\textbf{large}~--- под данные и под программу выделяется n
сегментов, \smallskip

\textbf{huge}~--- позволяет использовать сегментов больше, чем
позволяет ОП.

\begin{center}
    \includegraphics[width = 100mm]{4_9.png}
    \includegraphics[width = 100mm]{4_10.png}
\end{center}

\begin{center}
    \Large{\textbf{Com"=файлы}}
\end{center}

\textbf{После обработки} компилятором и редактором связей получаем
exe"=файл, который содержит блок начальной загрузки, размером не менее
512 байт, но существует возможность создания другого вида исполняемого
файла, который может быть получен на основе exe"=файла с помощью системной
обрабатывающей программы \textbf{EXE2BIN.com} или его можно создать с 
помощью среды разработки. Но не из всякого exe"=файла можно создать
com"=файл. Исходный файл, для которого можно создать com"=файл,
должен удовлетворять определённым требованиям. \smallskip 

\textbf{Отличия exe"=файла от com"=файла:} \smallskip

В com"=файлах отсутствует блок начальной загрузки и следовательно он 
занимает меньше места, чем exe"=файл. \smallskip

exe"=файл может занимать произвольный объём ОП. com"=файл может занимать
только один сегмент памяти. \smallskip

Стек создаётся автоматически ОС, поэтому у пользователя нет необходимости 
выделять для него место. Данные располагаются там же, где и
программа. \smallskip

Т.к. вся программа содержится в одном сегменте, перед выполнением программы
все сегментные регистры содержат в качестве значения адрес префикса 
программного сегмента~--- PSP. \smallskip

textbf{PSP}~--- 256 байтный блок, который содержится в exe"=фале,
так и в com"=файле, и т.к. адрес первой исполняемой команды отстоит на 256
байт (100h) байтов от адреса начала сегмента, то сразу после директивы 
\textbf{ASSUME} используется специальная директива \textbf{org 100h},
осуществляющая обход префикса программного сегмента.

\begin{center}
    \includegraphics[width = 100mm]{4_11.png}
    \newpage
    \includegraphics[width = 100mm]{4_12.png}
    \includegraphics[width = 100mm]{4_13.png}
\end{center}

\begin{center}
    \Large{\textbf{Арифметические операции}}
\end{center}

\textbf{Сложение (вычитание)} беззнаковых чисел выполняется по правилам
аналогичным сложению (вычитанию) по модулю $2^k$ принятым в математике
\dots В информатике, если в результате более k разрядов, то k+1"=й
пересылается в CF.

\begin{center}
    \includegraphics[width = 80mm]{4_14.png}
\end{center}

Пример, работая с байтами, получим:

\begin{center}
    \includegraphics[width = 80mm]{4_15.png}
\end{center}

Пример: в байте

\begin{center}
    \includegraphics[width = 80mm]{4_16.png}
\end{center}

\textbf{Сложение} (вычитание) знаковых чисел сводится к сложению
(вычитанию) с использованием дополнительного кода.

\begin{center}
    \includegraphics[width = 100mm]{4_17.png}
\end{center}

Ответ получили в ддополнительном коде, следовательно результат получаем
в байте по формуле \textbf{X = $10^n - |X|$, т.е.}

\begin{center}
    x = 256 - 254 = |2| и знак минус. Ответ -2.
\end{center}

Переволнение происходит если есть перенос из старшего цифрового в знаковый,
а из знакового нет и наоборот, тогда OF = 1. Программист сам решает какой
флажок анализировать OF или CF, зная с какими данными он
работает. \smallskip

\textbf{Арифметические} операции изменяют значение флажков OF, CF, SF, ZF,
AF, PF.