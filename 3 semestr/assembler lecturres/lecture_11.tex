При выполнении программы свободные и занятые ячейки динамияеской памяти
располагаются не последовательно, а произвольно, потому что элементы
списков в программе создаются произвольно и произвольным образом удаляются.

Чтобы создать элемент списка место выделяется в куче, а при удалении
элемента из списка рабочей программы это место добавляется в динамическую
память, поэтому для простоты работы с динамической памятью, её
можно объединить в список. Адрес начала списка хранится в некоторой
фиксированной ячейке, а список называют списком свободной памяти (ССП),
и тогда работать с ним можно как с обычным списком.

Назовём указатель на начло ССП heapptr, работаем с ним по-обычному.

Указатель heapptr должен храниться в начале кучи, в ячейке с относительным
адресом 0.

Описание сегмента кучи, в котором может разместиться n элементов размером в
двойное слово: (слайд 49)

Адрес начала кучи должен храниться в ES и программист загружает его туда
сам, а байты этого сегмента нужно объявить в список. heapptr указывает 
на начало списка, тогда: (слайд 49)

Инициализация кучи и загрузка её начала в регитр ES: (слайд 50)

Заголовок процедуры new и dispose

Процедура создания может выглядеть следующим образом:

(слайд 51)

Пример процедуры dispose:
Процедуре dispose передаётся адрес удаляемого элемента в регистре DI,
которую нужно присоединить к ССП.

(слайд 52)

Заголовок макросредства в языке ассемблер

Макросредства - самое сильное средство программирования (а может и нет).

К макросредствам относятся:

1) блоки повторений.

2) макросы.

3) директивы условной генерации.

заголовок блоки повторений

Блоки повторений позволяют включать в исходный текст программы
последовательности команд и количество включений такой последовательности
зависит от заголовка блока. Кроме того, от заголовка блока зависит
будет ли эта последовательность команд повторяться n раз в неизменном виде
или в каком-то модифицированном.

Макросы больше походи на подпрограммы
потому что существует описание или определение макроса, его называют 
макроопределением. И существвует обращение к макросу, которое называют
макрокомандой.

Выполнение макрокоманды называется макроподстановкой, в результате 
которой в исхоном тексте программы, на месте макрокоманды, появляется
макрорасширение. Сколько мы огратимся к макросы, сколько будет макрокоманд
в программе, столько макрорасширений появится в исходном тексте программы.

Макрос отличается от подпрограммы:

1) при обращении к подпрограмме мы передаём управление на участок памяти, где
хранится определение подпрограммы, а при обращении к макросу мы получаем
в исходном тексте тело макроса.

2) при использовании макросов мы экономим время на обращение к
подпрогрмамме и возврат из неё, но проигрываем в памяти.

3) если повторяется небольшой фрагмент программы, то рекомендуют использовать
макросы, ну а если впомогательный алгоритм большой, то используем
подпрограмму.

Программа, содержащая макросредства, транслируется и ассемблируется в
несколько этапов, на 1 этапе программа преобразуется в числый код без 
макросредств (препроцессорная обработка или макрогенерация), а 
на втором этапе происходит преобразование в машинный код.

Нужно сказать, что как блоки повторений, так и определение макросов
могут располагаться в самой программе, могут соержаться в файлах на диске
и подключаться с помощью директивы include <имя файла>

Заголовок Блоки повторений

Общий вид блока повторений: (слайд)

тело - любое количество любых операторов, предложений, в том числе и блоков
повторений.

endm определяет конец тела блока. Количество повторений телп и способы модификации
тела блока зависит от заголовка.

Возможны следующие заголовки:

(слайд 55)

Оно может быть вычислено на этапе макрогенерации, в рещультате которого
n копий теда блока записывается в данном месте программы.

Пример (слайд 55)

Можно создать массив, состоящий из ASCII кодов прописных русских букв:
(слайд 56)

Пример (задержка работы процессора на время выполенения команд jmp)

(слайд 56)

Второй вид заголовка (слайд 57)

P - формальный параметр

Vk - фактические параметры

<> - не мета символы, а символы языка (они оябзательны)

И при макрогенерации тело блока будет повторяться k раз, но не в неизменном
виде, а так, чтобы в i-той копии формальный параметр будет замещён фактическим
параметром Vi.

P - символическое имя, если оно случайно совпадёт с служебным именем, то ничего
страшного не произойдёт.

Список фактический параметров, если он пуст, то блок просто игнорируется.

Например: (слайд 57)

Например: (слайд 58)

Фактическим параметром может быть как объект программы, так и чать команды,
часть предложения, главное, чтобы после подстановки получиласть
правильная команда ассемблера.

Например: (слайд 58)

Вид заголовка (3)
(слайд 59)

P - формальный параметр

Si - символы, любые, кроме ; и пробела.

И при выполнении макрогенерации на месте этого блока будет k копий тела,
так что в i-той копии формальные параметр P замещён на Si.

Чтобы пробел и ; были фаткическими параметрами нужно заключить всю последовательность
в угловые скобки.

Пример (слайд 59)

Заголовок Макрооператоры

Макрооператоры могут использоваться в блоках повторений и в макроопределениях,
для записи формальных и фактических параметровa.

Таких макрооператоров 5:

амперсант - указывает границу формального параметра, чтобы выделить этот параметр из
общего текста, после макрогенерации этот символ пропадает.

Например(слайд 60)

Если несколько знаков амперсант стоит рядом, то макрогенератор за 1 проход 
открывает 1 знак амперсанта.

Пример (слайд 61)

Макрооператор <> - угловые скобки, действует так: весь текст, заключённый 
в скобки действует как строка. Этот маркооператор используется часто
для передачи параметров (слайд 61-62).

Макрооператор ! - действует так же как угловыве скобки, но на 1 символ.

Макроопрератор процент - говорит макрогенератору, что слудующий за ним текст
нужно вычислить как значение выражения и использовать как параметр.

Например (слайд 62)

Макрооператор ;; - определяет макрокоментарий. Текст макрокоментария не
включается в макрорасширения и в листининг программы.