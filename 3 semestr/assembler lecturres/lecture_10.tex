Заголовок строки переменной длины

Со строками в ассемблере можно работать как в с++ (недостаток, если неэффективно
сравнивать строки большой длины), когда строка заканчивается
признаком конца строки и при увеличении или уменьшении строки этот признак конца строки
нужно переносить, а можно работать как в языке Паскаль. Вначале указывается длина строки, 
а затем символы строки, сколько места нужно отводить под длину строки завист
от количества символов в строке. Если в строке может быть не более 255 символов,
то на строку достаточно 1 байта, и тогда, если имя строки, например S, то 
по адресу S содержится длина строки S+i - i-ый символ строки.

Например, посмотрим пример программы, удалить из строки S первое вхождение
символа *. (слайд 41)

Заголовок представление и работа со списками

Односвязный линейный список можно представить следующим образом: (слайд)

В каждом элементе списка есть информациооная часть (info) и связывающая часть
(link), стандартных процедур для роботы со списками в асссемблере нет. Динамические
переменные располагаются в специальной области оперативной памяти, которую
называют кучей (heap). Размер кучи зависит от количества динамических переменных, то 
есть от количества и длины списков в программе. Допустим, что для кучи достаточно 64кб
и пусть начало кучи определяет регистр ES, если внутри динамической памяти элемент имеет
адрес A (смещение относительно начала кучи), то полный физический адрес кучи определяется
ES:A, но поскольку ES для всех переменных ES один и тот же, то адрес элемента - А,
пусть информационное поле занимает 2 байта, тогда элемент списка можно предстваить как
следующую структуру (слайд)

Элемент можно описать как A node<>. Доступ к полям этой переменной можно записать 

ES: A.elem

ES: A.next

Пустая ссылка. Определи константу NULL EQU 0 и будем пользоваться этим символическим 
именет так же как в с++. Ссылки на первые элементы списков обычно хранятся в
статической памяти, например в DS, как переменные размером в слово (слайд)

Чтобы работать со списком, мы просматриваем элементы списка 1 за други и для 
этого нужно знать адрес текущего элемента списка. Испольуем для хранения этого адреса
регистр BX, в котором будет храниться только смещение текущего элемента, смещение 
текущего элемента - адрес относительно начала списка. Для обращения:

ES:[BX]

Просто нельзя писать поскольку по умолчанию мы работаем с регистром BS, тогда
обращение к полям текущего списка это есть 


ES:[BX].elem и  ES:[BX].next

1) Анализ информациионного поля (слайд)

2) переход к следующему элементу списка (слайд)

3) Проверка на конец списка (слайд)

4) поиск элемента с заданным значением информациооного поля:
Если nsp - начало списка, x - искомая величина, в AL записываем 1, если элемент есть, иначе
0. Тогда (слайд)

5) Вставка нового элемнета в список:

В ассемблере нет процедуры new, которая выделяет место для нового элемента в куче, её
нужно создавать самим, но пусть для нас такая процедура есть и она выделяет в куче адрес
байта, начиная с которого, можно разместить следующий элемент списка и этот адрес
процедура new(её нужно написать самому) передаёт через регистр DI, тогда вставить 
элемент в начало списка. (слайд)

6) удаление элемента из списка:

Пусть для адреса 1-ого элемнета списка используем BX, для 2-ого DI и предполагаем,
что у нас уже сть процедура dispose DI, которая удаляет элемент с адресом DI, освобождая
место в динамической памяти.

Реализация (слайд)

